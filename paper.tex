\documentclass[10pt]{article}
\usepackage{fullpage}
\usepackage[pdftex]{graphicx}
\usepackage{rotating}
\usepackage{multirow}
\usepackage{subfigure}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{wasysym}

\newcommand{\etal}{\emph{et al.}}

\begin{document}
\title{K Nearest Neighbour Search Using Space-filling Curves}
\author{Camara Lerner \hspace{2cm} Christopher Rabl \\
  Department of Mathematics and Computer Science\\
  University of Lethbridge, Canada}

\maketitle

\begin{abstract}

\end{abstract}

\section{Introduction}


\section{Hilbert Curve}


Formula for Gray Code:
$ gc(i) = i \oplus \left( i \gg 1 \right)$ 

Formula for $g(i) = \lfloor \log _{2} \left( gc(i) \oplus gc(i+1) \right) \rfloor + 1$

Formula for
\[ d(i) = \left\{ 
  \begin{array}{l l}
    0 & \quad \text{if $i = 0$}\\
    g(i - 1) \text{ mod } n & \quad \text{if $i$ is even} \\
    g(i) \text{ mod }  n & \quad \text{if $i$ is odd}
  \end{array} \right.\]

Formula for the bitwise right rotation:
$a \rightturn i = \left[ a_{n - 1 + i\text{ mod }n} \ldots a_{i\text{ mod }n} \right]_{\left[ 2 \right]}, \text{ where } a = \left[ a_{n-1} \ldots a_0\right]_{\left[ 2 \right]} $

The bitwise left rotation is similar.

Formula for 
\[ e(i) = \left\{ 
  \begin{array}{l l}
    0 & \quad \text{if $i = 0$}\\
    e(i - 1) \oplus 2^{d(i-1)} \oplus 2^{g(i-1)}& \quad \text{otherwise} \\
  \end{array} \right.\]

\begin{table}

  \begin{tabular}{l}
    \hline
    Algorithm for Gray Code Inverse $\left( gc^{-1}\left( g \right) \right)$\\
    \hline
    Given $g \in \mathbb{N}$, calculates the $i \in \mathbb{N}$ such that $gc\left( i \right) = g $ \\
    {\bf Input:} $g \in \mathbb{N}$\\
    {\bf Output:} $i \in \mathbb{N}$ such that $gc \left( i \right) = g $\\
    1: $ m \leftarrow $ number of bits to represent $g$ \\
    2: $ \left( i, j \right) \leftarrow \left( g, 1 \right) $ \\
    3: {\bf while} $ j < m $ {\bf do} \\
    4: {     } $ i \leftarrow i \oplus \left( g \gg j \right)$ \\
    5: {     } $ j \leftarrow j + 1$ \\
    6: {\bf end while} \\
    \hline
    % \oplus is exclusive or
    % \ll left shift
    % \gg right shift
    % \mid bitwise or
  \end{tabular}
  \label{gray-code-inverse}
\end{table}

\begin{table}
  
  \begin{tabular}{l}
    \hline
    Algorithm for Hilbert Index $(hi(n, m, {\bf p}))$ \\
    \hline
    Calculates the Hilbert index corresponding to the point ${\bf p} \in \mathbb{N}^n $ \\
    {\bf Input:} $n, m \in \mathbb{N} - \{0\} $ and a point ${\bf p} \in \mathbb{N}^n$ \\
    {\bf Output:} $h \in \mathbb{N}$, the Hilbert index of the point ${\bf p}$. \\
    1: $ \left( h, e, d \right) \leftarrow \left( 0, 0, 0 \right) $ \\
    2: {\bf for} $ i = m - 1 $ to $ 0 $ { \bf do} \\
    3: {     } $ l \leftarrow \left[ \left( p_{n-1} , i \right) \ldots \left( p_0 , i \right) \right]_{\left[ 2 \right]} $ \\
    4: {     } $ l \leftarrow \left( b \oplus e \right) \rightturn \left( d+1 \right)$ \\
    5: {     } $ w \leftarrow gc^{-1} \left( l \right)$ \\
    6: {     } $ e \leftarrow e \oplus \left( e \left( w \right) \leftturn \left( d+ 1 \right) \right) $ \\
    7: {     } $ d \leftarrow d + d \left( w \right) + 1 $ mod $n$ \\
    8: {     } $ h \leftarrow \left( h \ll n \right) | w $ \\
    9: {\bf end for} \\
    \hline
  \end{tabular}
  \label{hilbert-point-to-index}
\end{table}

\end{document}

